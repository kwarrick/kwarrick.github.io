<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bash on warrick.io</title>
    <link>//warrick.io/tags/bash/</link>
    <description>Recent content in Bash on warrick.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 09 Dec 2014 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="//warrick.io/tags/bash/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>current directory hell</title>
      <link>//warrick.io/posts/current-directory-hell/</link>
      <pubDate>Tue, 09 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>//warrick.io/posts/current-directory-hell/</guid>
      <description>One of the most frustrating and frequent scripting errors I make is in mistaking my current directory and improperly referencing another file or directory.
I have adopted a scope-like block style for changing directories using pushd and popd:
#!/bin/bash  mkdir lib/gdb pushd lib/gdb sudo apt-get build-dep -y gdb sudo apt-get install -y libpython2.7 libpython2.7-dev apt-get source gdb pushd gdb-?.?.? ./configure \  --with-python=$VIRTUAL_ENV/bin/python \  --prefix=$VIRTUAL_ENV make make install popd popd</description>
    </item>
    
    <item>
      <title>trap to cleanup</title>
      <link>//warrick.io/posts/trap-to-cleanup/</link>
      <pubDate>Mon, 20 Jan 2014 22:48:10 +0000</pubDate>
      
      <guid>//warrick.io/posts/trap-to-cleanup/</guid>
      <description>function cleanup() { rm -v $TEMPFILE } # catch HUP, INT, QUIT, and TERM trap cleanup 1 2 3 15</description>
    </item>
    
    <item>
      <title>bash regex matching</title>
      <link>//warrick.io/posts/bash-regex-matching/</link>
      <pubDate>Fri, 02 Mar 2012 02:18:15 +0000</pubDate>
      
      <guid>//warrick.io/posts/bash-regex-matching/</guid>
      <description>Incredibly, Bash allows you to do regular expression comparisons with the =~ operator that Ruby and Perl use:
$ if [[ &amp;#34;foo&amp;#34; =~ f.* ]]; then echo match fi match http://tldp.org/LDP/abs/html/abs-guide.html#REGEXMATCHREF</description>
    </item>
    
    <item>
      <title>bash c-style escapes </title>
      <link>//warrick.io/posts/bash-c-style-escapes/</link>
      <pubDate>Tue, 28 Feb 2012 18:59:33 +0000</pubDate>
      
      <guid>//warrick.io/posts/bash-c-style-escapes/</guid>
      <description>$ echo $&amp;#39;hello\nworld&amp;#39; hello world</description>
    </item>
    
    <item>
      <title>search and replace continued</title>
      <link>//warrick.io/posts/search-and-replace-continued/</link>
      <pubDate>Fri, 27 Jan 2012 02:49:27 +0000</pubDate>
      
      <guid>//warrick.io/posts/search-and-replace-continued/</guid>
      <description>As an extension of Recycling Arguments and the previous post on search and replace using Sed, I would like to show two Bash features for search in replace in previous commands:
Replace the first instance of foo in the previous command with bar:
$ cat foo $ ^foo^bar cat bar  OR
$ cat foo $ !!:s/foo/bar  As you can see the second example uses the word designator with a syntax similar to that of Sed.</description>
    </item>
    
    <item>
      <title>shell uptime</title>
      <link>//warrick.io/posts/shell-uptime/</link>
      <pubDate>Fri, 13 Jan 2012 03:23:46 +0000</pubDate>
      
      <guid>//warrick.io/posts/shell-uptime/</guid>
      <description>Bash has many reserved variables, but one of the most fun for screen junkies is the $SECONDS variable, which displays &amp;ldquo;the number of seconds since the shell was started&amp;rdquo;.
$ echo $SECONDS 2012339 $ echo $(($SECONDS/60)) minutes 33541 minutes $ echo $(($SECONDS/60/60)) hours 559 hours $ echo $(($SECONDS/60/60/24)) days 23 days  http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html</description>
    </item>
    
    <item>
      <title>bash extglob</title>
      <link>//warrick.io/posts/bash-extglob/</link>
      <pubDate>Fri, 13 Jan 2012 03:08:34 +0000</pubDate>
      
      <guid>//warrick.io/posts/bash-extglob/</guid>
      <description>Bash has many advanced features that may not be enabled by default, and as an avid wildcard wielder I find extglob especially useful.
I use inverse pattern matching most frequently, for example:
$ ls bar baz foo.jpg quux ^ $ ls !(*.jpg) bar baz quux To enable extglob, simply run:
$ shopt -s extglobIf the extglob shell option is enabled using the shopt builtin, several extended pattern matching operators are recognized.</description>
    </item>
    
    <item>
      <title>bash tcp connections</title>
      <link>//warrick.io/posts/bash-tcp-connections/</link>
      <pubDate>Tue, 03 Jan 2012 21:32:07 +0000</pubDate>
      
      <guid>//warrick.io/posts/bash-tcp-connections/</guid>
      <description>Bash, if compiled accordingly, has pseudo-device files that allow you to open TCP connections:
$ # /dev/tcp/$host/$port  $ echo foo &amp;gt; /dev/tcp/127.0.0.1/57005 Of course, nc is a more functional alternative, but this is an interesting bash feature nonetheless.
http://tldp.org/LDP/abs/html/devref1.html</description>
    </item>
    
    <item>
      <title>Recycle Arguments</title>
      <link>//warrick.io/posts/recycle-arguments/</link>
      <pubDate>Fri, 09 Dec 2011 02:36:11 +0000</pubDate>
      
      <guid>//warrick.io/posts/recycle-arguments/</guid>
      <description>Ok, so last post was a bit heavy. How about some more bash. So, thanks to sudo the !! word designator has become very popular:
$ apache2ctl restart Permission denied: ... $ sudo !! sudo apache2ctl restart Very cool, but you can also reuse arguments with the !! word designator:
$ cp /home/user/some/really/long/path /home/user/foo $ ls -lha !!:1 ls -lha /home/user/some/really/long/path So this !!:n lets you grab the nth argument, which is cool.</description>
    </item>
    
  </channel>
</rss>