<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on warrick.io</title>
    <link>//warrick.io/tags/linux/</link>
    <description>Recent content in Linux on warrick.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 06 Apr 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="//warrick.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>remap capslock in linux</title>
      <link>//warrick.io/posts/remap-capslock-linux/</link>
      <pubDate>Mon, 06 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>//warrick.io/posts/remap-capslock-linux/</guid>
      <description>Here is how I map CAPSLOCK + H/J/K/L to the arrow keys in Linux:
Remap the CAPSLOCK key with xmodmap:
cat &amp;gt;&amp;gt; ~/.xmodmaprc &amp;lt;&amp;lt;EOF clear Lock keycode 66 = ISO_Level3_Shift EOF Modify the xkb bindings:
cp /usr/share/X11/xkb/symbols/us ~/xkb-symbols-us.backup sudo sed -i -r &amp;#39;0,/h,\s+H/s//h, H, Left, Left/&amp;#39; /usr/share/X11/xkb/symbols/us sudo sed -i -r &amp;#39;0,/j,\s+J/s//j, J, Down, Down/&amp;#39; /usr/share/X11/xkb/symbols/us sudo sed -i -r &amp;#39;0,/k,\s+K/s//k, K, Up, Up/&amp;#39; /usr/share/X11/xkb/symbols/us sudo sed -i -r &amp;#39;0,/l,\s+L/s//l, L, Right, Right/&amp;#39; /usr/share/X11/xkb/symbols/us  Clean the cache:</description>
    </item>
    
    <item>
      <title>dynamic linking continued</title>
      <link>//warrick.io/posts/dynamic-linking-continued/</link>
      <pubDate>Tue, 16 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>//warrick.io/posts/dynamic-linking-continued/</guid>
      <description>In the last post, I showed how an unlinked library function invokes ld. In this post, I will show what happens in ld.
I talk about how eglibc does runtime linking in the current Ubuntu 14.04.1. However, it seems the two libraries glibc and eglibc have reconciled their past differences and eglibc has been discontinued. So, likely, Ubuntu will use glibc again in 15.
In any event, the two should be next to identical.</description>
    </item>
    
    <item>
      <title>dynamic linking</title>
      <link>//warrick.io/posts/dynamic-linking/</link>
      <pubDate>Mon, 15 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>//warrick.io/posts/dynamic-linking/</guid>
      <description>Deciphering the indirection of runtime dynamic linking can be a bit tricky.
I always seem to forget how the PLT and GOT interact.
Consider this simple example of calling the puts function in the dynamically linked libc:
#include &amp;lt;stdio.h&amp;gt; int main(int argc, char *argv[]) { puts(&amp;#34;foo bar baz qux&amp;#34;); return 0; }$ gcc test.c -o test # Show the dynamically linked libraries for the test binary. $ ldd test linux-gate.so.1 =&amp;gt; (0xb77d4000) libc.</description>
    </item>
    
    <item>
      <title>linux program execution</title>
      <link>//warrick.io/posts/linux-program-execution/</link>
      <pubDate>Wed, 22 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>//warrick.io/posts/linux-program-execution/</guid>
      <description>How does Linux load a program for execution? Overview
Loading an ELF executable into memory is handled by the load_elf_binary function in fs/binfmt_elf.c.
load_elf_binary performs consistency checks, allocates memory, and loads each segment into memory before calling the dynamic linker or starting execution of the program.
  Function Kernel File Annotation     1 shell  Enter a command.   2 execve()  Shell calls libc function.</description>
    </item>
    
    <item>
      <title>_start to main</title>
      <link>//warrick.io/posts/start-to-main/</link>
      <pubDate>Mon, 20 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>//warrick.io/posts/start-to-main/</guid>
      <description>Compiled with libc, a program&amp;rsquo;s _start procedure will simply call __libc_start_main:
_start: xor ebp, ebp ; zero ebp as recommended by ABI spec  pop esi ; pop argc into esi  mov ecx, esp ; move **argv to ecx, without altering stack  and esp, 0FFFFFFF0h ; mask clears bottom 4 bits, 16 byte align  push eax ; setup args for __libc_start_main [1]  push esp ; push *stack_end  push edx ; push *rtld_fini, linker destructor  push offset __libc_csu_fini ; push *fini, finalizer function pointer  push offset __libc_csu_init ; push *init, initializer function pointer  push ecx ; push **ubp_av, argv from stack  push esi ; push argc, argc from stack  push offset main ; push address of main(argc, argv, envp)  call ___libc_start_main ; call __libc_start_main procedure  hlt ; halt programint __libc_start_main( int (*main) (int, char**, char**), int argc, char **ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end) ); [1]: push eax is junk; only added to align to 8 arguments; never used.</description>
    </item>
    
    <item>
      <title>underclock a hot processor</title>
      <link>//warrick.io/posts/underclock-a-hot-processor/</link>
      <pubDate>Mon, 13 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>//warrick.io/posts/underclock-a-hot-processor/</guid>
      <description>I have a 125 watt processor that runs hot and overheats under heavy loads. Yeah it is a bit dusty. As a stopgap, until I get around to ordering a proper fan, I found a simple way to underclock the CPUs to keep it a bit cooler.
sudo apt-get install cpufrequtils for cpu in {0..3}; do sudo cpufreq-set -g userspace -c $cpu sudo cpufreq-set -u 2.20Ghz -c $cpu done You can check the available governors and current configuration with the cpufreq-info command:</description>
    </item>
    
    <item>
      <title>find duplicate files</title>
      <link>//warrick.io/posts/find-duplicate-files/</link>
      <pubDate>Thu, 19 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>//warrick.io/posts/find-duplicate-files/</guid>
      <description>Find duplicate files first by file size and then MD5 sum, with a progress bar:
find -not -empty -type f -printf &amp;#34;%s\n&amp;#34; \  | sort -rn \  | uniq -d \  | xargs -I{} -n1 find -type f -size {}c -print0 \  | tee \  | pv --line-mode --size $(find . -type f | wc -l) \  | xargs -0 md5sum \  | sort \  | uniq -w32 --all-repeated=separate \  | tee /tmp/duplicates http://www.</description>
    </item>
    
    <item>
      <title>spin down idle hard drive</title>
      <link>//warrick.io/posts/spin-down-idle-hard-drive/</link>
      <pubDate>Fri, 23 May 2014 00:00:00 +0000</pubDate>
      
      <guid>//warrick.io/posts/spin-down-idle-hard-drive/</guid>
      <description>I noticed that my external hard drive, which uses a cheap SATA to USB enclosure, was constantly spinning, even when I hadn&amp;rsquo;t accessed it in hours.
I decided to lookup how to coax the drive to spin down.
A little searching showed that you can check a drive&amp;rsquo;s status and set its idle timeout policy with the hdparm command.
$ sudo hdparm -C /dev/sdb /dev/sdb: drive state is: active/idle Setting the timeout is a little odd, the value 120 means 10 minutes.</description>
    </item>
    
    <item>
      <title>partial uniq using a lru cache</title>
      <link>//warrick.io/posts/partial-uniq-with-lru-cache/</link>
      <pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>//warrick.io/posts/partial-uniq-with-lru-cache/</guid>
      <description>Recently, I was faced with the challenge of removing duplicate lines from a number of large data files.
Typically, I use a combination or sort and uniq or just sort -u, but in this circumstance many duplicate lines were close together.
I found that, first, partially filtering duplicates by using a LRU cache to keep track of and omit recently seen lines doubled the speed.
#!/usr/bin/env python # file: lru-uniq.py import fileinput from repoze.</description>
    </item>
    
    <item>
      <title>fix slow ssh logins v2</title>
      <link>//warrick.io/posts/fix-ssh-logins-v2/</link>
      <pubDate>Mon, 17 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>//warrick.io/posts/fix-ssh-logins-v2/</guid>
      <description>Newer versions of OpenSSH attempt to reverse resolve client IP addresses. This can cause slow ssh connections if the client IP does not reverse resolve as the DNS request will be attempted multiple times and timeout each time.
To fix the problem, disable it in your /etc/ssh/sshd_config:
UseDNS no</description>
    </item>
    
    <item>
      <title>pam exec</title>
      <link>//warrick.io/posts/pam-exec/</link>
      <pubDate>Tue, 29 Oct 2013 04:07:12 +0000</pubDate>
      
      <guid>//warrick.io/posts/pam-exec/</guid>
      <description>PAM, the Linux Pluggable Authentication Modules, allows you to execute programs and scripts when SSH sessions are opened and closed.
# /etc/pam.d/sshd session optional pam_exec.so /path/to/script.sh# /path/to/script.sh  #!/bin/bash if [ $PAM_TYPE = &amp;#34;open_session&amp;#34; ]; then # fi exit 0 WARNING:
Botching your script or failing to return 0 will cause SSH login to fail. Don&amp;rsquo;t lock yourself out, test your script!</description>
    </item>
    
    <item>
      <title>piping to ruby scripts</title>
      <link>//warrick.io/posts/piping-to-ruby-scripts/</link>
      <pubDate>Wed, 16 Oct 2013 23:33:52 +0000</pubDate>
      
      <guid>//warrick.io/posts/piping-to-ruby-scripts/</guid>
      <description>Ruby, instead of exiting when it receives a SIGPIPE, throws an exception Errno:EPIPE which usually results in a stack trace.
./foo.rb:8:in `write&amp;#39;: Broken pipe - &amp;lt;STDOUT&amp;gt; (Errno::EPIPE) Here is the idiomatic one-line to simply exit when your script gets a SIGPIPE:
trap(&amp;#39;PIPE&amp;#39;, &amp;#39;EXIT&amp;#39;)</description>
    </item>
    
    <item>
      <title>tail</title>
      <link>//warrick.io/posts/tail/</link>
      <pubDate>Wed, 16 Oct 2013 22:59:37 +0000</pubDate>
      
      <guid>//warrick.io/posts/tail/</guid>
      <description>I didn&amp;rsquo;t know tail could be used to skip lines in a file:
Numbers having a leading plus (`+&amp;#39;) sign are relative to the beginning of the input# skip first line, start from second line tail -n+2 file</description>
    </item>
    
    <item>
      <title>how long is the linux kernel, in miles?</title>
      <link>//warrick.io/posts/how-long-is-the-linux-kernel-in-miles/</link>
      <pubDate>Wed, 24 Apr 2013 23:07:53 +0000</pubDate>
      
      <guid>//warrick.io/posts/how-long-is-the-linux-kernel-in-miles/</guid>
      <description>So, if we count the bytes in each .h, .s, and .c file what do we get?
find . -iname &amp;#39;*.c&amp;#39; -o -iname &amp;#39;*.h&amp;#39; -o -iname &amp;#39;*.s&amp;#39; -exec wc -c {} \; \  | ruby -n -e \  &amp;#34;puts ARGF.reduce(0) { |acc,val| acc + val.split.first.chomp.to_i }&amp;#34; # 9190080(12 + 2) / 300.0 * 9190080 / 12.0 / 5280.0 px font + px kerning / dpi * characters / foot / mile Approximately 6.</description>
    </item>
    
    <item>
      <title>reverse ssh tunnel</title>
      <link>//warrick.io/posts/reverse-ssh-tunnel/</link>
      <pubDate>Fri, 18 Jan 2013 16:22:59 +0000</pubDate>
      
      <guid>//warrick.io/posts/reverse-ssh-tunnel/</guid>
      <description>When I have a machine behind a NAT that I know I&amp;rsquo;ll need remote access to over the weekend, I add this rudimentary little script:
#!/bin/bash RUSER=warrick LPORT=5555 RHOST=&amp;#34;74.207.228.87&amp;#34; COMMAND=&amp;#34;ssh -N -f -R ${LPORT}:localhost:22 ${RUSER}@${RHOST}&amp;#34; pgrep -f -x &amp;#34;$COMMAND&amp;#34; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 || $COMMAND I then add this to the crontab, which runs the script every 5 minutes:
# KEY # +---------------- minute (0 - 59) # | +------------- hour (0 - 23) # | | +---------- day of month (1 - 31) # | | | +------- month (1 - 12) # | | | | +---- day of week (0 - 7 with Sunday=0 &amp;amp; 7) # | | | | | # * * * * * command to be executed */5 * * * * bash /home/user/rsshchk.</description>
    </item>
    
    <item>
      <title>multiple interfaces, multiple gateways</title>
      <link>//warrick.io/posts/multiple-interfaces-multiple-gateways/</link>
      <pubDate>Sun, 28 Oct 2012 03:17:55 +0000</pubDate>
      
      <guid>//warrick.io/posts/multiple-interfaces-multiple-gateways/</guid>
      <description>When configuring two interfaces, each on a different subnet, you must add an additional routing table to isolate interface traffic (e.g. eth0 in, eth0 out).
1. Create a routing table. In our example we create a table named &amp;lsquo;secondary&amp;rsquo; with identifier 252:
$ echo &amp;#39;252 secondary&amp;#39; &amp;gt;&amp;gt; /etc/iproute2/rt_tables If you check out /etc/iproute2/rt_tables you&amp;rsquo;ll see there are a few reserved identifiers one of which is for the primary routing table, main:</description>
    </item>
    
    <item>
      <title>chattr</title>
      <link>//warrick.io/posts/chattr/</link>
      <pubDate>Mon, 15 Oct 2012 19:34:36 +0000</pubDate>
      
      <guid>//warrick.io/posts/chattr/</guid>
      <description>A friend reminded me about chattr. Linux ext{2,3,4} filesystems have supplementary file attributes which can be modified with the &amp;ldquo;change attributes&amp;rdquo; utility found in the e2fsprogs package.
The two most interesting in my opinion are +/- i for immutable and +/- j for secure deletion:
$ sudo chattr +i /bin/ps $ sudo chattr +j secret.txt $ lsattr bar ----i----j---e- bar</description>
    </item>
    
    <item>
      <title>disable aslr</title>
      <link>//warrick.io/posts/disable-aslr/</link>
      <pubDate>Sat, 29 Sep 2012 17:05:49 +0000</pubDate>
      
      <guid>//warrick.io/posts/disable-aslr/</guid>
      <description>sudo sysctl -w kernel.</description>
    </item>
    
    <item>
      <title>linux syscalls</title>
      <link>//warrick.io/posts/linux-syscalls/</link>
      <pubDate>Fri, 15 Jun 2012 21:36:09 +0000</pubDate>
      
      <guid>//warrick.io/posts/linux-syscalls/</guid>
      <description>Where are linux system calls defined?
If you are crafting your own shellcode, you often need to find the syscall numbers. Syscalls are usually defined in:  /usr/include/asm/unistd_32.h /usr/include/asm/unistd_64.h</description>
    </item>
    
    <item>
      <title>iproute2</title>
      <link>//warrick.io/posts/iproute2/</link>
      <pubDate>Sat, 21 Apr 2012 23:06:37 +0000</pubDate>
      
      <guid>//warrick.io/posts/iproute2/</guid>
      <description>I was surprised to find out that ifconfig and route are actually deprecated, despite their ubiquity.
Even more unfortunate, their replacement, namely the ip command, doesn&amp;rsquo;t seem to have any concern for the readability of its output.
Here is how you would statically assign an IP, Netmask, Gateway, and DNS servers with ifconfig and route and the equivalent commands in ip:
$ ifconfig eth0 up $ ip link set eth0 up Configure your IP and Netmask:</description>
    </item>
    
    <item>
      <title>open</title>
      <link>//warrick.io/posts/open/</link>
      <pubDate>Sun, 26 Feb 2012 21:45:55 +0000</pubDate>
      
      <guid>//warrick.io/posts/open/</guid>
      <description>Mac OS X has an open command-line utility that I use extensively from the terminal. If ever I need to open a directory or any file with its default application, I just simply type open file and there is no need to open Finder and traverse to the directory.
# open a finder window in current directory $ open . $ open http://google.com $ open image.jpg In Linux, you can get the same functionality with gnome-open:</description>
    </item>
    
  </channel>
</rss>