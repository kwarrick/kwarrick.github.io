<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ld on warrick.io</title>
    <link>//warrick.io/tags/ld/</link>
    <description>Recent content in Ld on warrick.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 16 Dec 2014 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="//warrick.io/tags/ld/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>dynamic linking continued</title>
      <link>//warrick.io/posts/dynamic-linking-continued/</link>
      <pubDate>Tue, 16 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>//warrick.io/posts/dynamic-linking-continued/</guid>
      <description>In the last post, I showed how an unlinked library function invokes ld. In this post, I will show what happens in ld.
I talk about how eglibc does runtime linking in the current Ubuntu 14.04.1. However, it seems the two libraries glibc and eglibc have reconciled their past differences and eglibc has been discontinued. So, likely, Ubuntu will use glibc again in 15.
In any event, the two should be next to identical.</description>
    </item>
    
    <item>
      <title>dynamic linking</title>
      <link>//warrick.io/posts/dynamic-linking/</link>
      <pubDate>Mon, 15 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>//warrick.io/posts/dynamic-linking/</guid>
      <description>Deciphering the indirection of runtime dynamic linking can be a bit tricky.
I always seem to forget how the PLT and GOT interact.
Consider this simple example of calling the puts function in the dynamically linked libc:
#include &amp;lt;stdio.h&amp;gt; int main(int argc, char *argv[]) { puts(&amp;#34;foo bar baz qux&amp;#34;); return 0; }$ gcc test.c -o test # Show the dynamically linked libraries for the test binary. $ ldd test linux-gate.so.1 =&amp;gt; (0xb77d4000) libc.</description>
    </item>
    
  </channel>
</rss>