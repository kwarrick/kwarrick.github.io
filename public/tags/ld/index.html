<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">

    <title>Ld &middot; warrick.io</title>

    <link rel="stylesheet" href="//warrick.io/css/jane.css">
    <link rel="stylesheet" href="//warrick.io/css/syntax.css">
    <link rel="stylesheet" href="//warrick.io/css/font-awesome.css">


    <link href="//warrick.io/tags/ld/index.xml" rel="alternate" type="application/rss+xml" title="warrick.io" />
  </head>
  <body>
    
  <h1 class="brand">warrick.io</h1>

  <div class="links">
    <i class="fa-twitter-square"></i>
    <i class="fa-github-square"></i>
  </div>

  
    <article>
      <h2><a href="//warrick.io/posts/dynamic-linking-continued/">dynamic linking continued</a></h2>
      <time>Dec 16, 2014</time>
      

<p>In the last post, I showed how an unlinked library function invokes <code>ld</code>. In
this post, I will show what happens in <code>ld</code>.</p>

<p>I talk about how <code>eglibc</code> does runtime linking in the current Ubuntu 14.04.1.
However, it seems the two libraries <code>glibc</code> and <code>eglibc</code> have reconciled their
past differences and <code>eglibc</code> has been discontinued. So, likely, Ubuntu will
use <code>glibc</code> again in 15.</p>

<p>In any event, the two should be next to identical.</p>

<p>Find the sources for <code>/lib/ld-linux.so.2</code> in the <code>eglibc</code> package inside the
<code>elf</code> directory.</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ apt-get <span class="nb">source</span> eglibc</code></pre></div>
<h3 id="dl-fixup">_dl_fixup</h3>

<p>So, we left off in the last post with the binary jumping in the PLT to
<code>_dl_fixup</code>,</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm">  <span class="na">...</span>
 <span class="err">80482</span><span class="nl">f6:</span>  <span class="nf">push</span>   <span class="mi">0x0</span>                      <span class="c">; push index of puts in GOT
</span><span class="c"></span>  <span class="no">...</span>
 <span class="err">80482</span><span class="nl">e0:</span>  <span class="nf">push</span>   <span class="no">DWORD</span> <span class="no">PTR</span> <span class="no">ds</span><span class="p">:</span><span class="mi">0x804a004</span>   <span class="c">; push address of link_map
</span><span class="c"></span> <span class="mi">80482</span><span class="no">e6</span><span class="p">:</span>  <span class="no">jmp</span>    <span class="no">DWORD</span> <span class="no">PTR</span> <span class="no">ds</span><span class="p">:</span><span class="mi">0x804a008</span>   <span class="err">;</span> <span class="no">jump</span> <span class="no">to</span> <span class="no">_dl_fixup</span><span class="p">()</span> <span class="no">in</span> <span class="no">ld</span></code></pre></div>
<p>which is located in <code>dl-runtime.c</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// dl-runtime.c 
</span><span class="c1"></span><span class="n">_dl_fixup</span> <span class="p">(</span><span class="k">struct</span> <span class="n">link_map</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="n">ElfW</span><span class="p">(</span><span class="n">Word</span><span class="p">)</span> <span class="n">reloc_arg</span><span class="p">)</span>
<span class="p">{</span> 

  <span class="c1">// ...
</span><span class="c1"></span>  <span class="n">result</span> <span class="o">=</span> <span class="n">_dl_lookup_symbol_x</span> <span class="p">(</span><span class="n">strtab</span> <span class="o">+</span> <span class="n">sym</span><span class="o">-&gt;</span><span class="n">st_name</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sym</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_scope</span><span class="p">,</span>
				    <span class="n">version</span><span class="p">,</span> <span class="n">ELF_RTYPE_CLASS_PLT</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>Notice the function takes two arguments.</p>

<p>The address pushed at <code>0x80482e0</code> is an address to a <code>link_map</code> structure and
the <code>reloc_arg</code> argument is the index pushed for <code>puts</code> at <code>0x80482e0</code>.</p>

<p>In our example, <code>puts</code> is the only function and is thus at index <code>0x0</code>.</p>

<p>Without going into much detail, a <code>link_map</code> struct is maintained by <code>ld</code> for
all objects, the binary and linked libraries, and contains the important
addresses and state for linking.</p>

<p>You could consider the <code>link_map</code> the linker&rsquo;s internal representation of an
ELF.</p>

<h3 id="dl-lookup-symbol-x">_dl_lookup_symbol_x</h3>

<p>Ultimately, <code>_dl_fixup</code> calls the <code>_dl_lookup_symbol_x</code> function which uses
<code>reloc_arg</code> (<code>0x0</code> in our example) as index into the <code>.rel.plt</code> section:</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Relocation section &#39;.rel.plt&#39; at offset 0x298 contains 3 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804a00c  00000107 R_386_JUMP_SLOT   00000000   puts
0804a010  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__
0804a014  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main</code></pre></div>
<p>From the <code>.rel.plt</code>, <code>_dl_lookup_symbol_x</code> uses the Info field as an index
into the <code>.symtab</code> section:</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Symbol table &#39;.symtab&#39; contains 67 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
    52: 00000000     0 FUNC    GLOBAL DEFAULT  UND puts@@GLIBC_2.0</code></pre></div>
<p>Finally, <code>_dl_lookup_symbol_x</code> uses the Name field, <code>puts@GLIBC_2.0</code>, to
perform a scoped lookup of the function on other objects.</p>

<p>What is really interesting is how it actually searches other objects. It would
be very inefficient to perform a linear search of all other objects <code>.dynsym</code>
tables.</p>

<p>Actually, <code>ld</code> uses the <code>.hash</code> and <code>.gnu.hash</code> sections, which store hashes of
the symbol names.</p>

<p>There are two implementations the SYSV hash and the newer GNU method.</p>

<p>GNU hashing uses a bucketed bloom filter, you may have noticed in the readelf
output:</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">readelf -a /lib/i386-linux-gnu/libc.so.6

Histogram for `.gnu.hash&#39; bucket list length (total of 1011 buckets):
 Length  Number     % of total  Coverage
      0  100        (  9.9%)
      1  219        ( 21.7%)      9.2%
      2  260        ( 25.7%)     31.0%
      3  211        ( 20.9%)     57.6%
      4  133        ( 13.2%)     80.0%
      5  59         (  5.8%)     92.4%
      6  22         (  2.2%)     97.9%
      7  6          (  0.6%)     99.7%
      8  1          (  0.1%)    100.0%</code></pre></div>
<p>Find out more in this article:
<a href="https://blogs.oracle.com/ali/entry/gnu_hash_elf_sections">https://blogs.oracle.com/ali/entry/gnu_hash_elf_sections</a>.</p>

    </article>
  
    <article>
      <h2><a href="//warrick.io/posts/dynamic-linking/">dynamic linking</a></h2>
      <time>Dec 15, 2014</time>
      <p>Deciphering the indirection of runtime dynamic linking can be a bit tricky.</p>

<p>I always seem to forget how the PLT and GOT interact.</p>

<p>Consider this simple example of calling the <code>puts</code> function in the dynamically
linked <code>libc</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="n">puts</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;foo bar baz qux&#34;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ gcc test.c -o <span class="nb">test</span> 

<span class="c1"># Show the dynamically linked libraries for the test binary.
</span><span class="c1"></span>$ ldd <span class="nb">test</span> 
	linux-gate.so.1 <span class="o">=</span>&gt;  <span class="o">(</span>0xb77d4000<span class="o">)</span>
	libc.so.6 <span class="o">=</span>&gt; /lib/i386-linux-gnu/libc.so.6 <span class="o">(</span>0xb7615000<span class="o">)</span>
	/lib/ld-linux.so.2 <span class="o">(</span>0xb77d5000<span class="o">)</span></code></pre></div>
<p>Disassembling <code>test</code>, you&rsquo;ll find a call to <code>puts</code>, which is located in the
dynamically linked library <code>libc.so.6</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="err">0804842</span><span class="nl">d:</span>  <span class="nf">call</span>   <span class="mh">80482f0</span> <span class="p">&lt;</span><span class="no">puts@plt</span><span class="p">&gt;</span></code></pre></div>
<p>So, the PLT (procedure linkage table) is responsible for jumping to the <code>puts</code>
function if the dynamic linker <code>ld-linux.so.2</code> has already found the function
in libc, or otherwise jumping to <code>ld</code> to find and link the function:</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="err">080482</span><span class="nf">f0</span> <span class="err">&lt;</span><span class="no">puts@plt</span><span class="err">&gt;</span><span class="p">:</span>
 <span class="err">80482</span><span class="nl">f0:</span>   <span class="nf">jmp</span>    <span class="no">DWORD</span> <span class="no">PTR</span> <span class="no">ds</span><span class="p">:</span><span class="mi">0x804a00c</span>  <span class="c">; jump to address in 0x804a00c
</span><span class="c"></span> <span class="mi">80482</span><span class="no">f6</span><span class="p">:</span>   <span class="no">push</span>   <span class="mi">0x0</span>                     <span class="c">; push index of puts in GOT
</span><span class="c"></span> <span class="mi">80482</span><span class="no">fb</span><span class="p">:</span>   <span class="no">jmp</span>    <span class="mh">80482e0</span> <span class="p">&lt;</span><span class="no">_init</span><span class="p">+</span><span class="mi">0x30</span><span class="p">&gt;</span>    <span class="err">;</span> <span class="no">jump</span> <span class="no">to</span> <span class="no">ld</span> <span class="no">trampoline</span></code></pre></div>
<p>First, notice that the jump at <code>0x8048df0</code> is actually a jump to a <code>PTR</code>, which
means it does not jump to the address <code>0x804a00c</code> but rather the address stored
at that address:</p>

<pre><code>(gdb) info file
0x0804a000 - 0x0804a018 is .got.plt

(gdb) x/wx 0x804a00c
0x804a00c &lt;puts@got.plt&gt;:	0x080482f6
</code></pre>

<p>So, we can see that the address <code>0x804a00c</code> is actually in the <code>.got.plt</code>
section, and is where the address of <code>puts</code> will be stored when <code>ld</code> links the
function.</p>

<p>However, it is initialized to the value <code>0x080482f6</code>, which is actually the
address of <code>push 0x0</code>, directly below the jump.</p>

<p>After pushing the value <code>0x0</code> to the stack, we jump again to the code that will
actually take us into <code>ld</code> to perform the runtime lookup and linking:</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="err">080482</span><span class="nf">e0</span> <span class="err">&lt;</span><span class="no">puts@plt-0x10</span><span class="err">&gt;</span><span class="p">:</span>
 <span class="err">80482</span><span class="nl">e0:</span>  <span class="nf">push</span>   <span class="no">DWORD</span> <span class="no">PTR</span> <span class="no">ds</span><span class="p">:</span><span class="mi">0x804a004</span>   <span class="c">; push address of link_map
</span><span class="c"></span> <span class="mi">80482</span><span class="no">e6</span><span class="p">:</span>  <span class="no">jmp</span>    <span class="no">DWORD</span> <span class="no">PTR</span> <span class="no">ds</span><span class="p">:</span><span class="mi">0x804a008</span>   <span class="c">; jump to _dl_fixup() in ld
</span><span class="c"></span> <span class="mi">80482</span><span class="no">ec</span><span class="p">:</span>  <span class="no">add</span>    <span class="no">BYTE</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">eax</span><span class="p">],</span><span class="no">al</span></code></pre></div>
<p>Inspecting the two addresses, which you should note are stored immediately
before the <code>puts</code> address in the <code>.got.plt</code>, we see that both addresses are in
pages mapped to <code>ld</code>:</p>

<pre><code>(gdb) x/wx 0x804a004
0x804a004:	0xb7fff938

0xb7fff000 0xb8000000 rw-p	/lib/i386-linux-gnu/ld-2.19.so

(gdb) x/wx 0x804a008
0x804a008:	0xb7ff24f0

0xb7fde000 0xb7ffe000 r-xp	/lib/i386-linux-gnu/ld-2.19.so
</code></pre>

<p>So, you can see the first address is in writable space and the second
executable. In the next post, I&rsquo;ll discuss what happens in <code>ld</code>.</p>

    </article>
  

  </body>
</html>
