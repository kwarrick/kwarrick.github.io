<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">

    <title>dynamic linking &middot; warrick.io</title>

    <link rel="stylesheet" href="//warrick.io/css/jane.css">
    <link rel="stylesheet" href="//warrick.io/css/syntax.css">
    <link rel="stylesheet" href="//warrick.io/css/font-awesome.css">


    <link href="" rel="alternate" type="application/rss+xml" title="warrick.io" />
  </head>
  <body>
    
  <h1>dynamic linking</h1>
  <span class="post-date">Mon, Dec 15, 2014</span>
    <p>Deciphering the indirection of runtime dynamic linking can be a bit tricky.</p>

<p>I always seem to forget how the PLT and GOT interact.</p>

<p>Consider this simple example of calling the <code>puts</code> function in the dynamically
linked <code>libc</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="n">puts</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;foo bar baz qux&#34;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ gcc test.c -o <span class="nb">test</span> 

<span class="c1"># Show the dynamically linked libraries for the test binary.
</span><span class="c1"></span>$ ldd <span class="nb">test</span> 
	linux-gate.so.1 <span class="o">=</span>&gt;  <span class="o">(</span>0xb77d4000<span class="o">)</span>
	libc.so.6 <span class="o">=</span>&gt; /lib/i386-linux-gnu/libc.so.6 <span class="o">(</span>0xb7615000<span class="o">)</span>
	/lib/ld-linux.so.2 <span class="o">(</span>0xb77d5000<span class="o">)</span></code></pre></div>
<p>Disassembling <code>test</code>, you&rsquo;ll find a call to <code>puts</code>, which is located in the
dynamically linked library <code>libc.so.6</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="err">0804842</span><span class="nl">d:</span>  <span class="nf">call</span>   <span class="mh">80482f0</span> <span class="p">&lt;</span><span class="no">puts@plt</span><span class="p">&gt;</span></code></pre></div>
<p>So, the PLT (procedure linkage table) is responsible for jumping to the <code>puts</code>
function if the dynamic linker <code>ld-linux.so.2</code> has already found the function
in libc, or otherwise jumping to <code>ld</code> to find and link the function:</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="err">080482</span><span class="nf">f0</span> <span class="err">&lt;</span><span class="no">puts@plt</span><span class="err">&gt;</span><span class="p">:</span>
 <span class="err">80482</span><span class="nl">f0:</span>   <span class="nf">jmp</span>    <span class="no">DWORD</span> <span class="no">PTR</span> <span class="no">ds</span><span class="p">:</span><span class="mi">0x804a00c</span>  <span class="c">; jump to address in 0x804a00c
</span><span class="c"></span> <span class="mi">80482</span><span class="no">f6</span><span class="p">:</span>   <span class="no">push</span>   <span class="mi">0x0</span>                     <span class="c">; push index of puts in GOT
</span><span class="c"></span> <span class="mi">80482</span><span class="no">fb</span><span class="p">:</span>   <span class="no">jmp</span>    <span class="mh">80482e0</span> <span class="p">&lt;</span><span class="no">_init</span><span class="p">+</span><span class="mi">0x30</span><span class="p">&gt;</span>    <span class="err">;</span> <span class="no">jump</span> <span class="no">to</span> <span class="no">ld</span> <span class="no">trampoline</span></code></pre></div>
<p>First, notice that the jump at <code>0x8048df0</code> is actually a jump to a <code>PTR</code>, which
means it does not jump to the address <code>0x804a00c</code> but rather the address stored
at that address:</p>

<pre><code>(gdb) info file
0x0804a000 - 0x0804a018 is .got.plt

(gdb) x/wx 0x804a00c
0x804a00c &lt;puts@got.plt&gt;:	0x080482f6
</code></pre>

<p>So, we can see that the address <code>0x804a00c</code> is actually in the <code>.got.plt</code>
section, and is where the address of <code>puts</code> will be stored when <code>ld</code> links the
function.</p>

<p>However, it is initialized to the value <code>0x080482f6</code>, which is actually the
address of <code>push 0x0</code>, directly below the jump.</p>

<p>After pushing the value <code>0x0</code> to the stack, we jump again to the code that will
actually take us into <code>ld</code> to perform the runtime lookup and linking:</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="err">080482</span><span class="nf">e0</span> <span class="err">&lt;</span><span class="no">puts@plt-0x10</span><span class="err">&gt;</span><span class="p">:</span>
 <span class="err">80482</span><span class="nl">e0:</span>  <span class="nf">push</span>   <span class="no">DWORD</span> <span class="no">PTR</span> <span class="no">ds</span><span class="p">:</span><span class="mi">0x804a004</span>   <span class="c">; push address of link_map
</span><span class="c"></span> <span class="mi">80482</span><span class="no">e6</span><span class="p">:</span>  <span class="no">jmp</span>    <span class="no">DWORD</span> <span class="no">PTR</span> <span class="no">ds</span><span class="p">:</span><span class="mi">0x804a008</span>   <span class="c">; jump to _dl_fixup() in ld
</span><span class="c"></span> <span class="mi">80482</span><span class="no">ec</span><span class="p">:</span>  <span class="no">add</span>    <span class="no">BYTE</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">eax</span><span class="p">],</span><span class="no">al</span></code></pre></div>
<p>Inspecting the two addresses, which you should note are stored immediately
before the <code>puts</code> address in the <code>.got.plt</code>, we see that both addresses are in
pages mapped to <code>ld</code>:</p>

<pre><code>(gdb) x/wx 0x804a004
0x804a004:	0xb7fff938

0xb7fff000 0xb8000000 rw-p	/lib/i386-linux-gnu/ld-2.19.so

(gdb) x/wx 0x804a008
0x804a008:	0xb7ff24f0

0xb7fde000 0xb7ffe000 r-xp	/lib/i386-linux-gnu/ld-2.19.so
</code></pre>

<p>So, you can see the first address is in writable space and the second
executable. In the next post, I&rsquo;ll discuss what happens in <code>ld</code>.</p>

  </div>

  </body>
</html>
